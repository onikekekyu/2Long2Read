"""
DAG Airflow FONCTIONNEL pour l'analyse de Terms & Conditions Spotify.
Utilise BashOperator pour crÃ©er les pods workers directement via kubectl.
"""
import pendulum
from airflow.models.dag import DAG
from airflow.operators.bash import BashOperator
from datetime import timedelta

# Configuration par dÃ©faut du DAG
default_args = {
    'owner': '2long2read',
    'depends_on_past': False,
    'email_on_failure': False,
    'email_on_retry': False,
    'retries': 1,
    'retry_delay': timedelta(minutes=2),
}

with DAG(
    dag_id="spotify_cgu_analysis",
    default_args=default_args,
    description="Analyse complÃ¨te des CGU Spotify avec Claude AI",
    schedule=None,  # Manual trigger only
    start_date=pendulum.datetime(2025, 1, 1, tz="UTC"),
    catchup=False,
    tags=["2long2read", "spotify", "production"],
) as dag:

    # Task 1: CrÃ©er et lancer le worker pod pour Spotify
    analyze_spotify = BashOperator(
        task_id="analyze_spotify_terms",
        bash_command="""
        set -e

        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ðŸŽµ AIRFLOW: Analyse Spotify Terms & Conditions"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

        # Configuration
        TASK_ID="spotify-airflow-$(date +%Y%m%d-%H%M%S)"
        SPOTIFY_FILE="/opt/airflow/dags/raw_data/spotify_tc.txt"
        NAMESPACE="airflow"

        echo "ðŸ“‹ Task ID: $TASK_ID"
        echo "ðŸ“„ Source: Spotify Terms & Conditions"

        # Lire le contenu (10000 premiers caractÃ¨res)
        if [ -f "$SPOTIFY_FILE" ]; then
            CONTENT=$(head -c 10000 "$SPOTIFY_FILE" | base64 -w 0)
            echo "âœ… Fichier Spotify chargÃ©: $(echo $CONTENT | wc -c) bytes (base64)"
        else
            echo "âš ï¸  Fichier $SPOTIFY_FILE non trouvÃ©, utilisation contenu test"
            CONTENT=$(echo "SPOTIFY TERMS: Standard streaming terms with arbitration." | base64 -w 0)
        fi

        # CrÃ©er le manifest YAML
        POD_NAME="worker-$TASK_ID"

        cat > /tmp/${POD_NAME}.yaml <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: $POD_NAME
  namespace: $NAMESPACE
  labels:
    app: 2long2read-worker
    task-id: "$TASK_ID"
    source: "spotify"
    triggered-by: "airflow"
spec:
  restartPolicy: Never
  containers:
  - name: worker
    image: 2long2read-worker:latest
    imagePullPolicy: IfNotPresent
    command: ["sh", "-c"]
    args:
      - |
        echo "ðŸ“¥ DÃ©codage du contenu..."
        echo "$CONTENT" | base64 -d > /tmp/content.txt
        echo "ðŸš€ Analyse en cours..."
        python3 /app/worker.py \\
          --task-id "$TASK_ID" \\
          --source-name "spotify" \\
          --text-content "\$(cat /tmp/content.txt)"
    env:
      - name: MONGO_HOSTNAME
        value: "mongo-service.default.svc.cluster.local"
      - name: MONGO_PORT
        value: "27017"
      - name: ANTHROPIC_API_KEY
        value: "$ANTHROPIC_API_KEY"
      - name: CONTENT_BASE64
        value: "$CONTENT"
EOF

        # CrÃ©er le pod
        echo ""
        echo "ðŸš€ CrÃ©ation du worker pod..."
        kubectl apply -f /tmp/${POD_NAME}.yaml

        echo "âœ… Pod crÃ©Ã©: $POD_NAME"
        echo ""

        # Attendre que le pod dÃ©marre
        echo "â³ Attente du dÃ©marrage (max 60s)..."
        kubectl wait --for=condition=Ready pod/$POD_NAME -n $NAMESPACE --timeout=60s || true

        # Suivre les logs
        echo ""
        echo "ðŸ“‹ Logs du worker:"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        kubectl logs -f $POD_NAME -n $NAMESPACE 2>&1 || kubectl logs $POD_NAME -n $NAMESPACE 2>&1
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

        # Attendre la fin (max 5 min)
        echo ""
        echo "â³ Attente de la fin de l'analyse (max 5 min)..."
        kubectl wait --for=condition=Completed pod/$POD_NAME -n $NAMESPACE --timeout=300s 2>&1 || true

        # VÃ©rifier le statut final
        POD_STATUS=$(kubectl get pod $POD_NAME -n $NAMESPACE -o jsonpath='{.status.phase}' 2>/dev/null || echo "Unknown")

        echo ""
        echo "ðŸ“Š Statut final: $POD_STATUS"

        if [ "$POD_STATUS" = "Succeeded" ] || [ "$POD_STATUS" = "Completed" ]; then
            echo "âœ… Analyse terminÃ©e avec succÃ¨s!"
            echo "ðŸ’¾ Task ID: $TASK_ID"

            # Sauvegarder le task ID pour la prochaine tÃ¢che
            echo "$TASK_ID" > /tmp/last_task_id.txt

            exit 0
        else
            echo "âŒ Analyse Ã©chouÃ©e: $POD_STATUS"
            kubectl logs $POD_NAME -n $NAMESPACE --tail=30 2>&1 || true
            exit 1
        fi
        """,
        env={
            "ANTHROPIC_API_KEY": "{{ var.value.get('ANTHROPIC_API_KEY', '') }}",
        },
        execution_timeout=timedelta(minutes=10),
    )

    # Task 2: RÃ©cupÃ©rer et afficher les rÃ©sultats de MongoDB
    get_results = BashOperator(
        task_id="get_mongodb_results",
        bash_command="""
        set -e

        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ðŸ’¾ RÃ‰CUPÃ‰RATION DES RÃ‰SULTATS MONGODB"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

        # RÃ©cupÃ©rer le task ID de la tÃ¢che prÃ©cÃ©dente
        if [ -f /tmp/last_task_id.txt ]; then
            TASK_ID=$(cat /tmp/last_task_id.txt)
        else
            echo "âš ï¸  Task ID non trouvÃ©, recherche de la derniÃ¨re analyse Spotify..."
            # RÃ©cupÃ©rer la derniÃ¨re analyse Spotify
            MONGO_POD=$(kubectl get pods -n default -l app=mongo -o jsonpath='{.items[0].metadata.name}')
            TASK_ID=$(kubectl exec $MONGO_POD -n default -- \
                mongosh too_long_to_read --quiet --eval \
                'db.analytic_reports.find({"source_name":"spotify"}).sort({"_id":-1}).limit(1).toArray()[0].task_id' | tail -1)
        fi

        echo "ðŸ” Task ID: $TASK_ID"
        echo ""

        # RÃ©cupÃ©rer le pod MongoDB
        MONGO_POD=$(kubectl get pods -n default -l app=mongo -o jsonpath='{.items[0].metadata.name}')

        echo "ðŸ“Š RÃ©sultats de l'analyse:"
        echo ""

        # Afficher le rÃ©sumÃ©
        kubectl exec $MONGO_POD -n default -- \
            mongosh too_long_to_read --quiet --eval "
            var doc = db.analytic_reports.findOne({\\\"task_id\\\": \\\"$TASK_ID\\\"});
            if (doc) {
                print('âœ… Status: ' + doc.status);
                print('');
                print('ðŸ“Š SCORES DE RISQUE:');
                print('  Overall: ' + doc.report.risk_scores.overall + '/100');
                print('  Data Privacy: ' + doc.report.risk_scores.data_privacy + '/100');
                print('  User Rights: ' + doc.report.risk_scores.user_rights + '/100');
                print('  Legal Protection: ' + doc.report.risk_scores.legal_protection + '/100');
                print('  Termination Risk: ' + doc.report.risk_scores.termination_risk + '/100');
                print('  Transparency: ' + doc.report.risk_scores.transparency + '/100');
                print('');
                print('ðŸ”´ Clauses dangereuses: ' + doc.report.dangerous_clauses.length);
                print('');
                print('ðŸ“ Verdict: ' + doc.report.executive_summary.overall_verdict);
            } else {
                print('âŒ Document non trouvÃ© pour task_id: $TASK_ID');
            }
            "

        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "âœ… Analyse complÃ¨te disponible dans MongoDB"
        echo "ðŸ“Š Consultez Grafana pour la visualisation"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        """,
        execution_timeout=timedelta(minutes=2),
    )

    # DÃ©finir les dÃ©pendances
    analyze_spotify >> get_results
